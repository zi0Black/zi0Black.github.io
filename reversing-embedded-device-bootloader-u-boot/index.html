<!doctype html><html lang=en-us>
<head>
<meta http-equiv=x-clacks-overhead content="GNU Terry Pratchett">
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel="shortcut icon" href=https://zi0Black.github.io/images/favicon.png>
<title>Reversing embedded device bootloader (u-boot) | zi0Black's Blog</title>
<meta name=title content="Reversing embedded device bootloader (u-boot)">
<meta name=description content="TODO">
<meta name=keywords content="reversing,arm,firmware,baremetal,u-boot,">
<meta property="og:title" content="Reversing embedded device bootloader (u-boot)">
<meta property="og:description" content="TODO">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zi0Black.github.io/reversing-embedded-device-bootloader-u-boot/"><meta property="og:image" content="https://zi0Black.github.io/images/share.png"><meta property="article:section" content="blog">
<meta property="og:site_name" content="zi0Black's Blog">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zi0Black.github.io/images/share.png">
<meta name=twitter:title content="Reversing embedded device bootloader (u-boot)">
<meta name=twitter:description content="TODO">
<meta itemprop=name content="Reversing embedded device bootloader (u-boot)">
<meta itemprop=description content="TODO">
<meta itemprop=wordCount content="1633"><meta itemprop=image content="https://zi0Black.github.io/images/share.png">
<meta itemprop=keywords content="reversing,arm,firmware,baremetal,u-boot,">
<meta name=referrer content="no-referrer-when-downgrade">
<style>body{font-family:Verdana,sans-serif;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}</style>
</head>
<body>
<header><a href=/ class=title>
<h2>zi0Black's Blog</h2>
</a>
<nav><a href=/>Home</a>
<a href=/blog>Blog</a>
</nav>
</header>
<main>
<h1>Reversing embedded device bootloader (u-boot)</h1>
<p>
<i>
<time datetime=0001-01-01 pubdate>
01 Jan, 0001
</time>
</i>
</p>
<content>
<p>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.</p>
<h2 id=pre-flights-checks->Pre-flights checks üßëüèø‚Äç‚úàÔ∏è</h2>
<p>This blog post is not intended to be a guide to reverse-engineering Arm firmware or a specific guide to attacking a
particular IoT device. But I only want to share my experience and perhaps save you some hours of life and some headache.</p>
<p>Some context before the take-off:</p>
<ul>
<li>The CPU is an ARM-Cortex A7</li>
<li>The bootloader is a customized u-boot (the binary is stripped)</li>
<li>I found the datasheet of <a href=https://support.hkvstar.com/file/Hi3519_Datasheet.pdf>SOC</a></li>
<li>I got the firmware image from the vendor site</li>
<li>Kernel and rootfs are encrypted</li>
<li>The IoT device doesn&rsquo;t use ARM Trust Zone</li>
<li>The device has secure boot enforced</li>
</ul>
<p>The main goal was to reverse the custom crypto function, retrieve the encryption key, and decrypt the kernel image.
The adventured ended slightly in a different way, but we managed to get the kernel image decrypted.</p>
<p>After the initial effort, @TheZ3r0 joined me on this adventure, giving me massive help with his crypto mana.</p>
<hr>
<h2 id=l_king-around>L‚óî_‚óîking around</h2>
<p>I was already aware that the u-boot image in the firmware was the only non-encrypted image/binary, but a simple string entropy would have solved any dumbs about it. If the bootloader is not encrypted, but the kernel is the first should be in charge to decrypt the second. Taking this assumption, I extracted the u-boot image from the firmware with Binwalk ( no black magic, only <code>binwalk -e firmware.bin</code>), then I used Binwalk again to extract from the image the <code>u-boot.bin</code> file.</p>
<p><img src=/blog-img/uboot-article/binwalk.png alt="binwalk picture"></p>
<p>Time to run <code>strings u-boot.bin</code>.</p>
<p><img src=/blog-img/uboot-article/extracted-uboot-strings.png alt="strings run"></p>
<p>Okay, we have a proper u-boot binary; let&rsquo;s check the boot arguments: <code>strings u-boot.bin | grep args</code>.</p>
<p><img src=/blog-img/uboot-article/boot-args.png alt="boot args image"></p>
<p>Nothing special, but now we know where the kernel is stored <code>/dev/mtdblock12</code> and that the filesystem is a <code>squashfs</code>.</p>
<p>From this point, the troubles started to pop-up&mldr;</p>
<p>I chose to load the u-boot.bin inside IDA; the loader did not recognise the format, so it was treated as a raw binary; the only thing I configured in this step was the architecture since I knew from the datasheet that it was an ARM little-endian.</p>
<p><img src=/blog-img/uboot-article/memory-org.png alt="Disasembly memory organization"></p>
<p>I had never had to define the memory in a decompiler, and I had no idea what data I needed to enhance this form with. So I posted a question on StackExchange and then published the link on Reddit.
In the meantime, I looked at the datasheet and found a table with all the device addresses mapped. From the mapping table, I learned that the RAM started at 0x8000_0000.
Maybe it&rsquo;s time to run some grep on strings results.</p>
<p><img src=/blog-img/uboot-article/address.png alt="strings pipe grep 0x"></p>
<blockquote>
<p>strings u-boot.bin | grep 0x</p>
</blockquote>
<p>Okay, so if the RAM starts at <code>0x8000_0000</code> makes sense if the kernel is loaded at <code>0x8200_0000</code>. But what is loaded in the main memory from <code>0x8000_0000</code> and <code>0x8200_0000</code>? And where is the U-boot? It should be loaded in a fixed address since it&rsquo;s the bootloader.</p>
<blockquote>
<p>I&rsquo;ve just taken my operating systems exams at university, and I&rsquo;m very confident about this. I could have probably looked more deeply into the datasheet or other documentation to find out. But at this point, someone had answered me on Reddit.</p>
</blockquote>
<h2 id=the-message>The message</h2>
<p><img src=/blog-img/uboot-article/blessthe28-reddit-message.jpg alt="blessthe28 answer"></p>
<p>With these suggestions and a couple of searches on Big-G, I can try again to load the binary into IDA.</p>
<p><img src=/blog-img/uboot-article/loader-config.png alt="LOADER configured"></p>
<blockquote>
<p>ARM instruction set to NO prevent IDA from starting auto analysis</p>
</blockquote>
<p>I later changed the config as follow:</p>
<ul>
<li>VFPv3</li>
<li>Thumb-2</li>
<li>Yes with FMA</li>
<li>ARMv7-A&R
Then in the &ldquo;Disassembly memory organization&rdquo; window, I used <code>0x8000_0000</code> as the loading address. With the binary loaded, I defined some doublewords at the beginning of the binary (just press D).</li>
</ul>
<p><img src=/blog-img/uboot-article/ida-doubleword.png alt="double word defined"></p>
<p>From the address <code>00</code> to <code>1C</code> seems valid ARM instructions as suggested by the Reddit user. So probably it&rsquo;s the Interrupt Vactor Table.
Immediately after (at <code>20</code>), we can see the data seems to be an address, and the most significant bit represents <code>8</code>; remember that the RAM starts at <code>0x8000_0000</code>. Those address all points to <code>0x8080</code>, so if the RAM starts at <code>0x8000</code>, the bootloader should be loaded at <code>0x0080_0000</code>.</p>
<p>Time to change the loading address to <code>0x8080_0000</code> and press C on the first instructions at the beginning of the binary.</p>
<blockquote>
<p>Now that the binary is loaded at the correct address, all offsets should point correctly to the inside of the binary (ex. strings)</p>
</blockquote>
<p><img src=/blog-img/uboot-article/ida-configured.png alt="IDA nice"></p>
<p>Now that we have everything set up correctly, we can see that IDA has recognized many functions and identified some code and data areas.
Memory references are now also shown, as can be seen from the image.
I started reversing the binary until I identified the function that read the kernel from the RAM and deciphered it.
In the meantime, I became curious to see how Ghidra behaved with this bare-metal binary.</p>
<h2 id=change-the-shoes-after-the-start>Change the shoes after the start</h2>
<p>After searching more material about bare-metal binary reversing, I came across this <a href="https://www.youtube.com/watch?v=q4CxE5P6RUE">video</a> made by @Stacksmashing. And I thought, okay, I need to give it a try and see where I come up. I&rsquo;m not going to explain how to configure Ghidra; watch the video I think is enough to start ;)</p>
<p>After loading the binary in Ghidra and configuring a few parameters, I enabled the aggressive ARM instruction finder and ran the auto analysis; this is the result.</p>
<p><img src=/blog-img/uboot-article/ghidra-start.png alt=image-ghidra></p>
<blockquote>
<p>NOTE: sometimes, the aggressive instruction finder define certain pure data as code, so pay attention</p>
</blockquote>
<p>I was amazed that Ghidra identified the Interrupt Vector Table out of the box and started finding functions. I suggest properly defining memory regions and their properties (ex. r-only, rw-only) before auto analyses to help the decompiler understand what is happening.
At this point, @TheZ3r0 joined me, and we chose to try a feature of the Ghidra Server; the shared projects are like using GIT for a decompiler ü§Ø.</p>
<p>At this point, we searched for constants associated with a well-known cryptographic algorithm. And we quickly identified the reverse flow, from reding the kernel from the memory to decrypt it.</p>
<p><img src=/blog-img/uboot-article/SHA256-costant.png alt=crypto-costants></p>
<p>Since we have a custom implementation of u-boot, we choose to do two things:</p>
<ul>
<li>Define common functions (we don&rsquo;t have external lib in this type of binary, but everything is inside it)</li>
<li>Import u-boot header files and create a custom DataTypes Library
@TheZ3r0 started reading some source code of u-boot and quickly identified where functions like memcpy, memcp and printf are exported and then we searched for their code pathers in the binary.</li>
</ul>
<p><img src=/blog-img/uboot-article/functions-export.png alt=ghidra-common-functions-export></p>
<p>Meanwhile, I started building the custom DataTypes Library. Ghidra has good support for importing the header files and resolving other imports automatically; sometimes, you need to fix the import order if you choose to import only a few header files. This process is far from being a smother automatically task. It requires some handwork and fix of header files in some cases if there&rsquo;s flavoured compiler definitions or variables defined in the make file.</p>
<p><img src=/blog-img/uboot-article/data-types.png alt=immage-data-types></p>
<p>Now that we make our life a little bit easier in the future steps, we can start digging deeper inside the cryptographic function.</p>
<h2 id=who-doesnt-love-crypto-reversing-me>Who doesn&rsquo;t love crypto reversing? me!</h2>
<p>After three days of reversing and a slight headache, we got something more or less understandable, but we still didn&rsquo;t understand several steps, and it seemed clear that it was a custom implementation of AES. Our initial idea was to get the encryption keys and function parameters and write a convenient python script to decrypt the kernel.</p>
<p><img src=/blog-img/uboot-article/firmware_get_key.png alt="crypto function decompiled"></p>
<blockquote>
<p>The image represents only one of the multiple functions involved in the decryption process and key derivation</p>
</blockquote>
<p>In the middle of the fourth day, we decided to change our approach and emulate the function that decrypts the kernel. But what to use?
Since we both used the Qiling framework, the first idea was to use this tool, but shortly afterwards, we realised that this was not possible, as it does not support this kind of binary. We went a step further and decided to use Unicorn, a CPU emulator that offers the API in python (much to the delight of @TheZ3r0). The information obtained so far from reversing was enough to properly configure Unicorn to emulate our function and load data into memory in the right places (aka where to put the kernel image).</p>
<p>The simplest and quickest way to achieve a result is to execute only the function&rsquo;s code that places the key in memory (after several operations on it) and proceeds to decrypt the image from memory and rewrite the decrypted image to the same address. By doing this, we can minimise all the requirements for successful execution.</p>
<p>This <a href=https://github.com/arkup/juniEmu>script</a> heavily inspired us to create our script and obtain a successful emulation.</p>
<blockquote>
<p>We could have published our script, but we were too ashamed of how bad it was.</p>
<p>We started working on a project to add bare-metal binary support to another framework; if it doesn&rsquo;t end up in the queue of projects started and never finished, you will see it published in a few months.</p>
</blockquote>
<p>A brief overview of the steps we followed:</p>
<ul>
<li>Load the binary at 0x8008_0000</li>
<li>Map additional RAM accordingly with access done by the binary</li>
<li>Set the PC at the beginning of the target function</li>
<li>set register from r0-r3 for arguments (additional arguments should be placed in the stack)</li>
<li>load the kernel image in memory accordingly with the address passed as an argument to the decrypt function</li>
<li>set a breakpoint before the return of the function</li>
<li>run the emulation üë®üèø‚Äçü¶≤ -> üë¥üèø</li>
<li>dump the memory, where you expect to find the image decrypted, for the length of the image</li>
</ul>
<p><img src=/blog-img/uboot-article/kernel-decrypted-in-memory.png alt=kernel-decrypted-in-memory></p>
<p>Et voila, here is our decrypted kernel.</p>
<h2 id=last-stepbonus>Last step/Bonus</h2>
<p>To load the Linux kernel into IDA or Ghidra, I recommend using this <a href=https://github.com/marin-m/vmlinux-to-elf>tool</a> to unpack a vmlinux into an ELF. The result was something very welcome, especially since someone had left the symbols in the kernel build.</p>
<p><img src=/blog-img/uboot-article/kernel-loaded-in-decompiler.png alt=kernel-decompiled></p>
</content>
<p>
<a href=https://zi0Black.github.io/blog/reversing/>#reversing</a>
<a href=https://zi0Black.github.io/blog/arm/>#arm</a>
<a href=https://zi0Black.github.io/blog/firmware/>#firmware</a>
<a href=https://zi0Black.github.io/blog/baremetal/>#baremetal</a>
<a href=https://zi0Black.github.io/blog/u-boot/>#u-boot</a>
</p>
</main>
<footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo  ï‚Ä¢·¥•‚Ä¢ î Bear</a>
</footer>
</body>
</html>